#!/usr/bin/env ruby
ENV["RAILS_ENV"] = 'builder'
require File.dirname(__FILE__) + '/../config/boot'
require 'optparse'

OPTIONS = { :verbose => false }

ARGV.options do |opts|
  opts.banner = "Usage: cruise builder <project_name> []options]"

  opts.separator ""

  opts.on("-t", "--trace", "Trace-level (verbose) logging") { OPTIONS[:verbose] = true }
  opts.on("-h", "--help",
          "Show this help message.") { puts opts; exit }

  args = opts.parse!

  unless args.length == 1
    STDERR.puts "Project name not specified"
    STDERR.puts
    puts opts
    exit(-1)
  end

  OPTIONS[:project_name] = args[0]
  OPTIONS[:log_file_name] = "log/#{OPTIONS[:project_name]}_builder.log"
end

require RAILS_ROOT + "/config/environment"
CruiseControl::Log.verbose = OPTIONS[:verbose]

project_path = File.expand_path(File.join(Configuration.builds_directory, OPTIONS[:project_name]))

unless File.exist? project_path
  STDERR.puts "Project '#{OPTIONS[:project_name]}' not found in '#{project_path}'"
  exit(-1)
end

def cleanup(project)
  puts "Builder for project '#{OPTIONS[:project_name]}' exited" rescue nil
  CruiseControl::Log.event "Builder for project '#{OPTIONS[:project_name]}' exited" rescue nil
  if project
    ProjectBlocker.release(project) rescue nil
  end
end

project = nil

begin
  project = Project.load_or_create(project_path)

  # this will create builder.pid file in project's CC directory and grab an exclusive lock on it, or else blow up saying 
  # that something else is already locking it
  ProjectBlocker.block(project)

  puts "Builder for project '#{project.name}' started"
  puts "Logging to: #{File.expand_path(OPTIONS[:log_file_name])}"
  CruiseControl::Log.event "Builder for project '#{project.name}' started"

  project.scheduler.run
rescue => e
  begin 
    CruiseControl::Log.error(e.message)
    CruiseControl::Log.error(e.backtrace)
  rescue => logging_error
    STDERR.puts e.message
    STDERR.puts e.backtrace
    STDERR.puts "Attempt to log the above error failed with this:"
    STDERR.puts logging_error.message
    STDERR.puts logging_error.backtrace
  end
  STDERR.puts "[error] #{e.message}"
  OPTIONS[:verbose] ? raise : exit(1)
ensure 
  cleanup(project)
end
